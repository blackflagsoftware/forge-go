package {{.ProjectNameAllLower}}

import (
	"fmt"

	"github.com/jmoiron/sqlx"
	ae "{{.ProjectPath}}/internal/api_error"
	stor "{{.ProjectPath}}/internal/storage"
	"{{.ProjectPath}}/internal/util"
)

type (
	SQL{{.ProjectNameCamel}} struct {
		DB *sqlx.DB
	}
)

func InitSQL() *SQL{{.ProjectNameCamel}} {
	db := stor.{{.SQLProvider}}Init()
	return &SQL{{.ProjectNameCamel}}{DB: db}
}

func (d *SQL{{.ProjectNameCamel}}) Read({{.ProjectNameAbbr}} *{{.ProjectNameCamel}}) error {
	sqlGet := {{.StorageTablePrefix}}`
		SELECT
			{{.StorageGetColumns}}
		FROM {{.StorageTable}} WHERE {{.StorageTableKeyKeys}}`{{.StorageTablePostfix}}
	if errDB := d.DB.Get({{.ProjectNameAbbr}}, sqlGet, {{.StorageTableKeyValues}}); errDB != nil {
		return ae.DBError("{{.ProjectNameCamel}} Get: unable to get record.", errDB)
	}
	return nil
}

func (d *SQL{{.ProjectNameCamel}}) ReadAll({{.ProjectNameAbbr}} *[]{{.ProjectNameCamel}}, param {{.ProjectNameCamel}}Param) (int, error) {
	searchStmt, args := util.BuildSearchString(param.Search)
	sqlSearch := fmt.Sprintf(`
		SELECT
			{{.StorageGetColumns}}
		FROM {{.StorageTable}}
		%s
		ORDER BY %s %s`, searchStmt, param.Sort, param.Limit)
	sqlSearch = d.DB.Rebind(sqlSearch)
	if errDB := d.DB.Select({{.ProjectNameAbbr}}, sqlSearch, args...); errDB != nil {
		return 0, ae.DBError("{{.ProjectNameCamel}} Search: unable to select records.", errDB)
	}
	sqlCount := fmt.Sprintf(`
		SELECT
			COUNT(*)
		FROM {{.StorageTable}}
		%s`, searchStmt)
	var count int
	sqlCount = d.DB.Rebind(sqlCount)
	if errDB := d.DB.Get(&count, sqlCount, args...); errDB != nil {
		return 0, ae.DBError("{{.StorageTable}} Search: unable to select count.", errDB)
	}
	return count, nil
}

func (d *SQL{{.ProjectNameCamel}}) Create({{.ProjectNameAbbr}} *{{.ProjectNameCamel}}) error {
	sqlPost := {{.StorageTablePrefix}}`
		INSERT INTO {{.StorageTable}} (
			{{.StoragePostColumns}}
		) VALUES (
			{{.StoragePostColumnsNamed}}
		){{.StoragePostReturning}}`{{.StorageTablePostfix}}
	{{.StoragePostQuery}}
	if errDB != nil {
		return ae.DBError("{{.ProjectNameCamel}} Post: unable to insert record.", errDB)
	}
	{{.StoragePostLastId}}
	return nil
}

func (d *SQL{{.ProjectNameCamel}}) Update({{.ProjectNameAbbr}} {{.ProjectNameCamel}}) error {
	sqlPatch := {{.StorageTablePrefix}}`
		UPDATE {{.StorageTable}} SET
			{{.StoragePatchColumns}}
		WHERE {{.StoragePatchWhere}}`{{.StorageTablePostfix}}
	if _, errDB := d.DB.NamedExec(sqlPatch, {{.ProjectNameAbbr}}); errDB != nil {
		return ae.DBError("{{.ProjectNameCamel}} Patch: unable to update record.", errDB)
	}
	return nil
}

func (d *SQL{{.ProjectNameCamel}}) Delete({{.ProjectNameAbbr}} *{{.ProjectNameCamel}}) error {
	sqlDelete := {{.StorageTablePrefix}}`
		DELETE FROM {{.StorageTable}} WHERE {{.StorageTableKeyKeys}}`{{.StorageTablePostfix}}
	if _, errDB := d.DB.Exec(sqlDelete, {{.StorageTableKeyValues}}); errDB != nil {
		return ae.DBError("{{.ProjectNameCamel}} Delete: unable to delete record.", errDB)
	}
	return nil
}
