package loginrole

import (
	ae "{{.ProjectPath}}/internal/api_error"
	a "{{.ProjectPath}}/internal/audit"
	"{{.ProjectPath}}/internal/util"
)

//go:generate mockgen -source=manager.go -destination=mock.go -package=loginrole
type (
	DataLoginRoleAdapter interface {
		Read(*LoginRole) error
		ReadAll(*[]LoginRole, LoginRoleParam) (int, error)
		Create(*LoginRole) error
		Update(LoginRole) error
		Delete(*LoginRole) error
	}

	ManagerLoginRole struct {
		dataLoginRole DataLoginRoleAdapter
		auditWriter   a.AuditAdapter
	}
)

func NewManagerLoginRole(clo DataLoginRoleAdapter) *ManagerLoginRole {
	aw := a.AuditInit()
	return &ManagerLoginRole{dataLoginRole: clo, auditWriter: aw}
}

func (m *ManagerLoginRole) Get(lo *LoginRole) error {
	if lo.LoginUid == "" {
		return ae.MissingParamError("LoginUid")
	}
	if lo.RoleUid == "" {
		return ae.MissingParamError("RoleUid")
	}
	return m.dataLoginRole.Read(lo)
}

func (m *ManagerLoginRole) Search(lo *[]LoginRole, param LoginRoleParam) (int, error) {
	param.Param.CalculateParam("login_uid", map[string]string{"login_uid": "login_uid"})

	return m.dataLoginRole.ReadAll(lo, param)
}

func (m *ManagerLoginRole) Post(lo *LoginRole) error {

	if err := m.dataLoginRole.Create(lo); err != nil {
		return nil
	}
	go a.AuditCreate(m.auditWriter, *lo, LoginRoleConst, a.KeysToString("login_uid", lo.LoginUid, "role_uid", lo.RoleUid))
	return nil
}

func (m *ManagerLoginRole) Patch(loIn LoginRolePatch) error {
	// get old list
	loginRoleParam := LoginRoleParam{util.Param{Search: []util.ParamSearch{util.ParamSearch{Column: "login_uid", Compare: "=", Value: loIn.LoginUid}}}}
	existingLoginRoles := []LoginRole{}
	_, errSearch := m.dataLoginRole.ReadAll(&existingLoginRoles, loginRoleParam)
	if errSearch != nil {
		return errSearch
	}
	exisingRoles := []string{}
	for _, e := range existingLoginRoles {
		exisingRoles = append(exisingRoles, e.RoleUid)
	}
	// compare new to old
	addRoles := util.ArrayDiff(exisingRoles, loIn.RoleUids)
	for _, add := range addRoles {
		if err := m.dataLoginRole.Create(&LoginRole{LoginUid: loIn.LoginUid, RoleUid: add}); err != nil {
			return err
		}
	}
	deleteRoles := util.ArrayDiff(loIn.RoleUids, exisingRoles)
	for _, del := range deleteRoles {
		if err := m.dataLoginRole.Delete(&LoginRole{LoginUid: loIn.LoginUid, RoleUid: del}); err != nil {
			return err
		}
	}
	return nil
}

func (m *ManagerLoginRole) Delete(lo *LoginRole) error {
	if lo.LoginUid == "" {
		return ae.MissingParamError("LoginUid")
	}
	if lo.RoleUid == "" {
		return ae.MissingParamError("RoleUid")
	}
	if err := m.dataLoginRole.Delete(lo); err != nil {
		return err
	}
	go a.AuditDelete(m.auditWriter, *lo, LoginRoleConst, a.KeysToString("login_uid", lo.LoginUid, "role_uid", lo.RoleUid))
	return nil
}
